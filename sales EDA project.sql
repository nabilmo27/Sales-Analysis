--explore all countries customers comes from 
select distinct country
from gold.dim_customers;


-- explore all categories 
select distinct category,subcategory,product_name
from gold.dim_products;

-- find the date of the first and last order
select min(order_date),max(order_date),DATEDIFF(YEAR,min(order_date),max(order_date)) as date_range
from gold.fact_sales

-- find youngest and oldest customers 
select
MIN(birthdate),
datediff(year,MIN(birthdate),getdate()) as oldest_age ,
max(birthdate),
datediff(year,max(birthdate),getdate()) as youngest_age
from gold.dim_customers;

-- Find the total Sales
SELECT FORMAT(SUM(sales_amount), 'N0') AS total_sales
FROM gold.fact_sales
-- Find how many items are sold
SELECT FORMAT(SUM(quantity), 'N0') AS total_sales
FROM gold.fact_sales
-- Find the average selling price
SELECT
	FORMAT(avg(price), 'N0') AS avg_price
FROM gold.fact_sales
-- Find the Total number of Orders
select 
	 COUNT(distinct order_number) as number_of_orders
from gold.fact_sales
-- Find the total number of products
select
	count(distinct product_id)
from gold.dim_products;
-- Find the total number of customers
select count(distinct customer_id) from gold.dim_customers
-- Find the total number of customers that has placed an order
select count(distinct customer_key) from gold.fact_sales

-- Generate a Report that shows all key metrics of the business
SELECT 'Total Sales' AS measure_name, FORMAT(SUM(sales_amount), 'N0') AS measure_value FROM gold.fact_sales
UNION
SELECT 'Total Quantity', FORMAT(SUM(quantity), 'N0') FROM gold.fact_sales
UNION
SELECT 'Average Price', FORMAT(AVG(price), 'N2') FROM gold.fact_sales
UNION
SELECT 'Total Nr. Orders', FORMAT(COUNT(DISTINCT order_number), 'N0') FROM gold.fact_sales
UNION
SELECT 'Total Nr. Products', FORMAT(COUNT(product_name), 'N0') FROM gold.dim_products
UNION
SELECT 'Total Nr. Customers', FORMAT(COUNT(customer_key), 'N0') FROM gold.dim_customers;



-- Find total customers by countries
select 
	country,
	COUNT(distinct customer_id) as tot_customers
from gold.dim_customers
group by country
order by tot_customers desc

-- Find customers by gender
select
	gender,
	COUNT(distinct customer_id) as tot_customers
from gold.dim_customers
group by gender
order by tot_customers desc
-- Find total products by category
select 
category,
COUNT(distinct product_id) as total_products
from gold.dim_products
group by category
order by total_products desc
-- Find the average cost in each category
select 
category,
avg(cost) as avg_cost
from gold.dim_products
group by category
order by avg_cost desc

-- Find the total revenue generated for each category
select category,format(SUM(sales_amount),'N0') as tot_rev
from 
	gold.fact_sales
	left join  gold.dim_products on gold.fact_sales.product_key = gold.dim_products.product_key
group by  category

-- Find the total revenue generated by each customer
select 
	gold.dim_customers.customer_key,
	first_name,
	last_name,
	format(SUM(sales_amount),'N0') as tot_rev
from gold.fact_sales
	left join  gold.dim_customers on gold.fact_sales.customer_key = gold.dim_customers.customer_key
group by
	   gold.dim_customers.customer_key,
		first_name,
		last_name
order by tot_rev desc
-- Find the distribution of sold items across countries
select country,SUM(quantity)  tot_sold_items
from 
gold.fact_sales
left join gold.dim_customers on gold.fact_sales.customer_key = gold.dim_customers.customer_key
group by country
order by tot_sold_items desc


-- Which 5 products generated the highest revenue
    SELECT top 5
        product_name,
        SUM(sales_amount) AS tot_rev
    FROM gold.fact_sales
    LEFT JOIN gold.dim_products 
        ON gold.fact_sales.product_key = gold.dim_products.product_key
    GROUP BY product_name
	order by tot_rev desc;


   SELECT * from (
        select product_name,
        SUM(sales_amount) AS tot_rev, ROW_NUMBER()over(order by  SUM(sales_amount) desc) as ranking
    FROM gold.fact_sales
    LEFT JOIN gold.dim_products 
        ON gold.fact_sales.product_key = gold.dim_products.product_key
    GROUP BY product_name)t1
	  where ranking<=5 ;

-- top 10 customers eho generated highest revenue
select top 10
	dim_customers.first_name,
	dim_customers.last_name,
	SUM(sales_amount) tot_rev
from gold.dim_customers
left join gold.fact_sales on gold.dim_customers.customer_key =gold.fact_sales.customer_key
group by dim_customers.first_name,
	dim_customers.last_name
order by SUM(sales_amount) desc

-- the 3 customers with fewest orders 
select top 50
	dim_customers.customer_key,
	dim_customers.first_name,
	dim_customers.last_name,
	count(distinct order_number) orders
from gold.dim_customers
left join gold.fact_sales on gold.dim_customers.customer_key =gold.fact_sales.customer_key
group by dim_customers.customer_key,dim_customers.first_name,
	dim_customers.last_name
order by count(distinct order_number)

-- sales over time
select 
year(order_date)as year,
month(order_date) as month,
sum(sales_amount) as tot_sales,
count(distinct customer_key) as tot_customers,
sum(quantity) as tot_quantity,
COUNT(distinct order_number) as tot_orders
from gold.fact_sales
group by year(order_date) ,month(order_date) 
order by year(order_date) ,month(order_date) 

-- calculate the total sales per month and running total over time
-- Monthly sales with running total
WITH monthly_sales AS (
    SELECT 
        DATETRUNC(month, order_date) AS order_month,
        SUM(sales_amount) AS tot_sales
    FROM gold.fact_sales
	where DATETRUNC(month, order_date) is not null
    GROUP BY DATETRUNC(month, order_date)
)
SELECT 
    order_month,
    tot_sales,
    SUM(tot_sales) OVER (ORDER BY order_month) AS running_total
FROM monthly_sales
ORDER BY order_month;

-- analyze the yearly performance of products comparing each products sales to bothits average sales peformance and prev.years sales
with yearly_product_sales as 
(
select 
	year(order_date) as order_year ,
	product_name, 
	sum(sales_amount) as revenue 
from gold.dim_products
left join gold.fact_sales on dim_products.product_key = fact_sales.product_key
where year(order_date) is not null
group by year(order_date) ,product_name
)
select 
	order_year,
	product_name,
	revenue,
	AVG(revenue) over( partition by product_name ) AS avg_sales,
-- avg analysis
	revenue-AVG(revenue) over( partition by product_name ) as avg_diff,
	case when revenue-AVG(revenue) over( partition by product_name )>0 then 'above average'
		 when revenue-AVG(revenue) over( partition by product_name )<0 then 'below average'
		 else 'average'
		 end as 'AVG staues',
-- year-over year analysis
    lag(revenue)over(partition by product_name order by order_year ) as prev_year_revenue,
	revenue-lag(revenue)over(partition by product_name order by order_year ) as py_diff,
	case when revenue-lag(revenue)over(partition by product_name order by order_year )>0 then 'increase'
		 when revenue-lag(revenue)over(partition by product_name order by order_year )<0 then 'decrease'
		 else 'no change'
		 end as 'yearly change'
from yearly_product_sales
order by product_name,order_year;

--which categories contribute the most overall sales ?
with category_sales as
(
select 
	category, 
	SUM(sales_amount) AS tot_sales
from gold.dim_products
join gold.fact_sales on dim_products.product_key = gold.fact_sales.product_key
group by category) 
select 
	* ,
	SUM(tot_sales) over () as overall_sales,
	concat(round((cast(tot_sales as float)/SUM(tot_sales) over ())*100,2),'%') as sales_percentage
from category_sales




-- Segment products into cost ranges and count how many products fall into each segment
WITH cost_segmentation AS (
  SELECT distinct
    product_name,
    cost,
    CASE
      WHEN cost < 100 THEN 'below 100'
      WHEN cost BETWEEN 100 AND 500 THEN '100-500'
      WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
      ELSE 'above 1000'
    END AS cost_category
  FROM gold.dim_products
  LEFT JOIN gold.fact_sales 
    ON dim_products.product_key = fact_sales.product_key
)
SELECT 
  cost_category,
  COUNT(*) AS product_count
FROM  cost_segmentation
GROUP BY cost_category
ORDER BY product_count DESC;




/* Group customers into three segments based on their spending behavior:
   - VIP: Customers with at least 12 months of history and spending more than €5,000.
   - Regular: Customers with at least 12 months of history but spending €5,000 or less.
   - New: Customers with a lifespan less than 12 months.
   And find the total number of customers by each group
*/
-- Segment customers based on spending and history duration
-- VIP: ≥12 months & > €5000 spending
-- Regular: ≥12 months & ≤ €5000 spending
-- New: <12 months history

WITH customer_segmentation AS (
  SELECT 
    dim_customers.customer_key,
    SUM(sales_amount) AS tot_sales,
    MIN(order_date) AS first_order,
    MAX(order_date) AS last_order,
    DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan,
    CASE 
      WHEN DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) >= 12 
           AND SUM(sales_amount) > 5000 THEN 'VIP customer'
      WHEN DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) >= 12 
           AND SUM(sales_amount) <= 5000 THEN 'Regular customer'
      ELSE 'New customer'
    END AS customer_category
  FROM gold.dim_customers
  LEFT JOIN gold.fact_sales 
    ON dim_customers.customer_key = fact_sales.customer_key
  GROUP BY dim_customers.customer_key
)

SELECT 
  customer_category,
  COUNT(customer_key) AS customer_count
FROM customer_segmentation
GROUP BY customer_category
ORDER BY customer_count DESC;


-----------------------------------------------------------
/* Product Report:
   - Consolidates key product metrics and behaviors
   - Gathers essential fields: product name, category, subcategory, cost
   - Segments products by revenue:
       • High-Performers
       • Mid-Range
       • Low-Performers
   - Aggregates product-level metrics:
       • Total orders
       • Total sales
       • Total quantity sold
       • Total unique customers
       • Lifespan (in months)
   - Calculates key KPIs:
       • Recency (months since last sale)
       • Average Order Revenue (AOR)
       • Average Monthly Revenue
*/--------------------------------------------------
-- Product Report View: Aggregates product metrics and segments performance

CREATE VIEW gold.product_report AS
WITH base_query AS (
  SELECT 
    s.order_number,
    s.order_date,
    s.customer_key,
	p.product_key,
    p.product_name,
    p.category,
    p.subcategory,
    s.quantity,
    p.cost,
    s.sales_amount
  FROM gold.fact_sales s
  LEFT JOIN gold.dim_products p 
    ON p.product_key = s.product_key
),

products_aggregations AS (
  SELECT 
    product_key,
    product_name,
    category,
    subcategory,
    cost,
    MIN(order_date) AS first_order,
    MAX(order_date) AS last_order,
    DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan,
    SUM(sales_amount) AS total_sales,
    COUNT(DISTINCT customer_key) AS total_customers,
    COUNT(DISTINCT order_number) AS total_orders
  FROM base_query
  GROUP BY 
    product_key,
    product_name,
    category,
    subcategory,
    cost
)

SELECT 
  product_key,
  product_name,
  category,
  subcategory,
  cost,
  lifespan,
  total_sales,
  total_customers,
  total_orders,
  DATEDIFF(MONTH, last_order, GETDATE()) AS recency_in_month,

  CASE 
    WHEN total_sales > 50000 THEN 'High performance'
    WHEN total_sales > 10000 THEN 'Mid range'
    ELSE 'Low performance'
  END AS product_segment,

total_sales  / total_orders AOV  -- Average Order Value

FROM products_aggregations;
























-- Customer Report View: Aggregates customer metrics and segments by age and value
-- Includes KPIs: total orders, total products, total sales, total quantity, lifespan, recency, AOV
-- Segments customers by age group and value (VIP, Regular, New)

CREATE VIEW gold.customer_report AS
WITH base_query AS (
  SELECT 
    s.order_number,
    s.product_key,
    s.sales_amount,
    s.quantity,
    s.order_date,
    c.customer_key,
    CONCAT(c.first_name, ' ', c.last_name) AS Full_Name,
    c.country,
    c.gender,
    DATEDIFF(YEAR, c.birthdate, GETDATE()) AS Age
  FROM gold.dim_customers c
  JOIN gold.fact_sales s 
    ON c.customer_key = s.customer_key
),

customer_aggregations AS (
  SELECT 
    customer_key,
    Full_Name,
    country,
    gender,
    Age,
    COUNT(DISTINCT order_number) AS total_orders,
    COUNT(DISTINCT product_key) AS total_products,
    SUM(sales_amount) AS total_sales,
    SUM(quantity) AS total_amount,
    MIN(order_date) AS first_order,
    MAX(order_date) AS last_order,
    DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan
  FROM base_query
  GROUP BY 
    customer_key,
    Full_Name,
    country,
    gender,
    Age
)

SELECT 
  customer_key,
  Full_Name,
  country,
  gender,
  Age,

  -- Age segmentation
  CASE 
    WHEN Age < 20 THEN 'Under 20'
    WHEN Age BETWEEN 20 AND 29 THEN '20-29'
    WHEN Age BETWEEN 30 AND 39 THEN '30-39'
    WHEN Age BETWEEN 40 AND 49 THEN '40-49'
    ELSE '50 and above'
  END AS age_group,

  total_orders,
  total_products,
  total_sales,
  total_amount,
  first_order,
  last_order,
  lifespan,

  -- Months since last order
  DATEDIFF(YEAR, last_order, GETDATE()) AS recency,

  -- Customer value segmentation
  CASE 
    WHEN lifespan >= 12 AND total_sales > 5000 THEN 'VIP'
    WHEN lifespan >= 12 AND total_sales <= 5000 THEN 'Regular'
    ELSE 'New'
  END AS customer_segmentation,

